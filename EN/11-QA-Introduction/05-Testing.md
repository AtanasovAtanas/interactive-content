# Testing

[slide]
# Video

[/slide]

[slide]
# What Is Testing?

Testing is a software check to see whether it **meets the requirements**, or whether there are bugs. This is the process of analyzing the software to find problems, defects it is testing. It can be done **manually**, it can be done by **QA**, the **marketing director** or **all together**. Anyone can find a bug, even the end user, but it is best for it to be found by the team. We check if the features are implemented correctly and if they do the work they are supposed to do.

These are the **main test activities**:

## Planning and Control

**Test Planning**: Test planning involves producing a document that describes an overall approach and test objectives. It involves **reviewing** the test basis, **identifying** the test conditions based on analysis of test items, **writing test cases** and Designing the test environment. Completion or exit criteria must be specified so that we know when testing (at any stage) is complete.

**Puprose**
* To determine the **scope** and **risks** and identify the objectives of testing;
* To determine the **required test resources** like people, test environments etc;
* To schedule **test analysis** and **design tasks**, test implementation, execution and evaluation;

**Control**
This is the activity of comparing actual progress against the plan, and reporting the status, including deviations from the plan. It involves taking actions necessary to meet the mission and objectives of the project.

## Analysis and Design

Test analysis and Test Design has the following major tasks:
* To review the test basis;
* To identify test conditions;
* To design the tests;
* To design the test environment set-up and identify the required infrastructure;

## Implementation and Execution

Test execution involves actually running the **specified test** on a **computer system** either manually or by using an automated test tool. It is a Fundamental Test Process in which actual work is done.

Test implementation has the following **major task**:

* To develop and prioritize test cases by using techniques;
* To create test suites from the test cases for efficient test execution;
* To re-execute the tests that previously failed in order to confirm a fix;
* To log the outcome of the test execution;
* To compare actual results with expected results;

## Evaluating Exit criteria and Reporting

Evaluating exit criteria is a process defining when to **stop testing**. It depends on coverage of code, functionality or risk. Basically it also depends on **business risk**, cost and time and vary from project to project. 

Exit criteria come into picture, **when**:
* Maximum test cases are executed with certain pass percentage;
* Bug rate falls below certain level;
* When we achieve the deadlines;

Evaluating exit criteria has the following **major tasks**:
* To assess if more test are needed or if the exit criteria specified should be changed;
* To write a test summary report for stakeholders;

## Test Closure activities:
Test closure activities are done when software is ready to be delivered. 
The testing can be closed for the other reasons also like:

* When a project is **cancelled**;
* When some target is **achieved**;
* When a maintenance release or update is **done**;
[/slide]

[slide]
# Software Requirement Specifications

A software requirements specification (**SRS**) is a document that describes what the software **will do** and how it **will be expected** to perform. It also describes the functionality the product needs to fulfill all stakeholders (business, users) needs.

A typical SRS includes:

* A purpose;
* An overall description;
* Specific requirements;

The best **SRS documents** define how the software will interact when embedded in hardware — or when connected to other software. Good SRS documents also account for real-life users.

## Why Use an SRS Document?

A software requirements specification is the **basis for your entire project**. It lays the framework that every team involved in development will follow.

It's used to provide **critical information** to multiple teams — development, quality assurance, operations, and maintenance. This keeps everyone on the same page.

Using the SRS helps to ensure **requirements are fulfilled**. And it can also help you make decisions about your product's lifecycle — for instance, when to retire a feature.

Writing an SRS can also minimize overall development time and costs. Embedded development teams especially benefit from using an SRS.
[/slide]

[slide]
# Test Process

[/slide]

[slide]
# Test Control

[/slide]

[slide]
# Test Plan

[/slide]

[slide]
# Test Execution

[/slide]

[slide]
# Test Summary Report

[/slide]